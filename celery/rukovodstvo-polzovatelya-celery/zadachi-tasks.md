# Задачи (tasks)

Задачи — это строительные блоки приложений **Celery**.

Задача — это класс, который можно создать _**из любого вызываемого объекта**_. Он выполняет двойную роль: определяет, что происходит, когда задача вызывается (отправляет сообщение), и что происходит, когда воркер получает это сообщение.

Каждый класс задач имеет уникальное имя, и на это имя ссылаются в сообщениях, чтобы воркер мог найти нужную функцию для выполнения.

Сообщение задачи не удаляется из очереди до тех пор, пока это сообщение не будет <mark style="color:purple;">подтверждено исполнителем</mark>. Воркер может заранее зарезервировать множество сообщений, и даже если воркер будет убит – из-за сбоя питания или по какой-либо другой причине – сообщение будет повторно доставлено другому воркеру.

В идеале функции задач должны быть <mark style="color:purple;">идемпотентными</mark>: это означает, что функция не будет вызывать непредвиденных эффектов, даже если она будет вызываться несколько раз с одними и теми же аргументами. Поскольку процесс воркера не может определить, являются ли ваши задачи идемпотентными, поведением по умолчанию является подтверждение сообщения заранее, непосредственно перед его выполнением, чтобы уже начатый вызов задачи никогда не выполнялся снова.

Если ваша задача идемпотентна, вы можете установить опцию [acks\_late](zadachi-tasks.md#tasks.acks\_late), чтобы вместо этого воркер подтверждал сообщение после возврата задачи. См. также раздел часто задаваемых вопросов. <mark style="color:purple;">Должен ли я использовать retry или acks\_late?</mark>.

Обратите внимание, что процесс воркера подтвердит сообщение, если дочерний процесс, выполняющий задачу, завершается (либо задачей, вызывающей [sys.exit()](https://docs.python.org/dev/library/sys.html#sys.exit), либо сигналом), даже если [acks\_late](zadachi-tasks.md#tasks.acks\_late) включен. Такое поведение является преднамеренным, поскольку…

1. Мы не хотим перезапускать задачи, которые заставляют ядро отправлять процессу **SIGSEGV** (ошибка сегментации) или подобные сигналы.
2. Мы предполагаем, что системный администратор, намеренно уничтоживший задачу, не хочет, чтобы она автоматически перезапускалась.
3. Задача, которая выделяет слишком много памяти, может вызвать срабатывание убийцы OOM ядра, то же самое может произойти снова.
4. Задача, которая всегда терпит неудачу при повторной доставке, может вызвать высокочастотный цикл сообщений, приводящий к сбою системы.

Если вы действительно хотите, чтобы задача была повторно доставлена в этих сценариях, вам следует рассмотреть возможность включения параметра <mark style="color:purple;">task\_reject\_on\_worker\_lost</mark>.

{% hint style="danger" %}
Задача, которая блокируется на неопределенный срок, может в конечном итоге помешать экземпляру воркера выполнять любую другую работу.

Если ваша задача выполняет ввод-вывод, обязательно добавьте таймауты к этим операциям, например, добавив таймаут к веб-запросу с помощью библиотеки [requests](https://pypi.python.org/pypi/requests/):&#x20;

```python
connect_timeout, read_timeout = 5.0, 30.0
response = requests.get(URL, timeout=(connect_timeout, read_timeout))
```

<mark style="color:purple;">Ограничения по времени</mark> удобны для обеспечения своевременного возврата всех задач, но событие ограничения по времени фактически принудительно останавливает процесс, поэтому используйте их только для обнаружения случаев, когда вы еще не использовали тайм-ауты вручную.

В предыдущих версиях планировщик пула **prefork** по умолчанию не был дружелюбен к длительным задачам, поэтому, если у вас были задачи, которые выполнялись в течение минут/часов, рекомендуется включить аргумент командной строки <mark style="color:purple;">-Ofair</mark> для **celery worker**. Однако, начиная с версии 4.0, `-Ofair` теперь является стратегией планирования по умолчанию. Дополнительные сведения см. в разделе «<mark style="color:purple;">Ограничения предварительной выборки</mark>», а также для обеспечения наилучшей производительности маршрутизации длительных и кратковременных задач выделенным исполнителям (<mark style="color:purple;">автоматическая маршрутизация</mark>).

Если ваш воркер зависает, прежде чем сообщать о проблеме, выясните, какие задачи выполняются, поскольку, скорее всего, зависание вызвано одной или несколькими задачами, зависающими в сетевой операции.
{% endhint %}

В этой главе вы узнаете все об определении задач, а вот ее содержание:

* [Основы](zadachi-tasks.md#osnovy)
* [Названия](zadachi-tasks.md#nazvaniya)
* Запрос задачи
* Ведение журнала
* Повторная попытка
* [Список параметров](zadachi-tasks.md#spisok-parametrov)
* Состояния
* Полупредикаты
* Пользовательские классы задач
* Как это работает
* Советы и лучшие практики
* Производительность и стратегии
* Пример

## Основы

Вы можете легко создать задачу из любого вызываемого объекта, используя декоратор <mark style="color:purple;">app.task()</mark>:

```python
from .models import User

@app.task
def create_user(username, password):
    User.objects.create(username=username, password=password)
```

Для задачи также можно задать множество опций, которые можно указать в качестве аргументов декоратора:

```python
@app.task(serializer='json')
def create_user(username, password):
    User.objects.create(username=username, password=password)
```

### Как импортировать декоратор задач?

Декоратор задач доступен в вашем экземпляре приложения <mark style="color:purple;">Celery</mark>. Если вы не знаете, что это такое, прочтите «[Первые шаги с Celery](../nachalo-raboty-s-celery/pervye-shagi-s-celery.md)».

Если вы используете Django (см. <mark style="color:purple;">Первые шаги с Django</mark>) или являетесь автором библиотеки, то вам, вероятно, захочется использовать декоратор **shared\_task()**:

```python
from celery import shared_task

@shared_task
def add(x, y):
    return x + y
```

### Несколько декораторов

При использовании нескольких декораторов в сочетании с декоратором задачи вы должны убедиться, что декоратор задачи применяется последним (как ни странно, в Python это означает, что он должен быть первым в списке):

```python
@app.task
@decorator2
@decorator1
def add(x, y):
    return x + y
```

### Связанные задачи

Привязка задачи означает, что первым аргументом задачи всегда будет экземпляр задачи (**self**), точно так же, как привязанные методы Python:

```python
logger = get_task_logger(__name__)

@app.task(bind=True)
def add(self, x, y):
    logger.info(self.request.id)
```

Связанные задачи необходимы для повторных попыток (с использованием <mark style="color:purple;">app.Task.retry()</mark>), для доступа к информации о текущем запросе задачи и для любых дополнительных функций, которые вы добавляете в базовые классы пользовательских задач.

### Наследование задач

Базовый аргумент декоратора задачи определяет базовый класс задачи:

```python
import celery

class MyTask(celery.Task):

    def on_failure(self, exc, task_id, args, kwargs, einfo):
        print('{0!r} failed: {1!r}'.format(task_id, exc))

@app.task(base=MyTask)
def add(x, y):
    raise KeyError()
```

## Названия

## Список параметров

### Общие

#### Tasks.acks\_late
