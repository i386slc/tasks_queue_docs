# Задачи (tasks)

Задачи — это строительные блоки приложений **Celery**.

Задача — это класс, который можно создать _**из любого вызываемого объекта**_. Он выполняет двойную роль: определяет, что происходит, когда задача вызывается (отправляет сообщение), и что происходит, когда воркер получает это сообщение.

Каждый класс задач имеет уникальное имя, и на это имя ссылаются в сообщениях, чтобы воркер мог найти нужную функцию для выполнения.

Сообщение задачи не удаляется из очереди до тех пор, пока это сообщение не будет <mark style="color:purple;">подтверждено исполнителем</mark>. Воркер может заранее зарезервировать множество сообщений, и даже если воркер будет убит – из-за сбоя питания или по какой-либо другой причине – сообщение будет повторно доставлено другому воркеру.

В идеале функции задач должны быть <mark style="color:purple;">идемпотентными</mark>: это означает, что функция не будет вызывать непредвиденных эффектов, даже если она будет вызываться несколько раз с одними и теми же аргументами. Поскольку процесс воркера не может определить, являются ли ваши задачи идемпотентными, поведением по умолчанию является подтверждение сообщения заранее, непосредственно перед его выполнением, чтобы уже начатый вызов задачи никогда не выполнялся снова.

Если ваша задача идемпотентна, вы можете установить опцию [acks\_late](zadachi-tasks.md#tasks.acks\_late), чтобы вместо этого воркер подтверждал сообщение после возврата задачи. См. также раздел часто задаваемых вопросов. <mark style="color:purple;">Должен ли я использовать retry или acks\_late?</mark>.

Обратите внимание, что процесс воркера подтвердит сообщение, если дочерний процесс, выполняющий задачу, завершается (либо задачей, вызывающей [sys.exit()](https://docs.python.org/dev/library/sys.html#sys.exit), либо сигналом), даже если [acks\_late](zadachi-tasks.md#tasks.acks\_late) включен. Такое поведение является преднамеренным, поскольку…

1. Мы не хотим перезапускать задачи, которые заставляют ядро отправлять процессу **SIGSEGV** (ошибка сегментации) или подобные сигналы.
2. Мы предполагаем, что системный администратор, намеренно уничтоживший задачу, не хочет, чтобы она автоматически перезапускалась.
3. Задача, которая выделяет слишком много памяти, может вызвать срабатывание убийцы OOM ядра, то же самое может произойти снова.
4. Задача, которая всегда терпит неудачу при повторной доставке, может вызвать высокочастотный цикл сообщений, приводящий к сбою системы.

Если вы действительно хотите, чтобы задача была повторно доставлена в этих сценариях, вам следует рассмотреть возможность включения параметра <mark style="color:purple;">task\_reject\_on\_worker\_lost</mark>.

{% hint style="danger" %}
Задача, которая блокируется на неопределенный срок, может в конечном итоге помешать экземпляру воркера выполнять любую другую работу.

Если ваша задача выполняет ввод-вывод, обязательно добавьте таймауты к этим операциям, например, добавив таймаут к веб-запросу с помощью библиотеки [requests](https://pypi.python.org/pypi/requests/):&#x20;

```python
connect_timeout, read_timeout = 5.0, 30.0
response = requests.get(URL, timeout=(connect_timeout, read_timeout))
```

<mark style="color:purple;">Ограничения по времени</mark> удобны для обеспечения своевременного возврата всех задач, но событие ограничения по времени фактически принудительно останавливает процесс, поэтому используйте их только для обнаружения случаев, когда вы еще не использовали тайм-ауты вручную.

В предыдущих версиях планировщик пула **prefork** по умолчанию не был дружелюбен к длительным задачам, поэтому, если у вас были задачи, которые выполнялись в течение минут/часов, рекомендуется включить аргумент командной строки <mark style="color:purple;">-Ofair</mark> для **celery worker**. Однако, начиная с версии 4.0, `-Ofair` теперь является стратегией планирования по умолчанию. Дополнительные сведения см. в разделе «<mark style="color:purple;">Ограничения предварительной выборки</mark>», а также для обеспечения наилучшей производительности маршрутизации длительных и кратковременных задач выделенным исполнителям (<mark style="color:purple;">автоматическая маршрутизация</mark>).

Если ваш воркер зависает, прежде чем сообщать о проблеме, выясните, какие задачи выполняются, поскольку, скорее всего, зависание вызвано одной или несколькими задачами, зависающими в сетевой операции.
{% endhint %}

В этой главе вы узнаете все об определении задач, а вот ее содержание:

* [Основы](zadachi-tasks.md#osnovy)
* [Названия](zadachi-tasks.md#nazvaniya)
* [Объект Request задачи Task](zadachi-tasks.md#obekt-request-zadachi-task)
* [Ведение журнала](zadachi-tasks.md#vedenie-zhurnala-logirovanie)
* [Повторная попытка](zadachi-tasks.md#povtornaya-popytka)
* [Список параметров](zadachi-tasks.md#spisok-parametrov)
* Состояния
* Полупредикаты
* Пользовательские классы задач
* Как это работает
* Советы и лучшие практики
* Производительность и стратегии
* Пример

## Основы

Вы можете легко создать задачу из любого вызываемого объекта, используя декоратор <mark style="color:purple;">app.task()</mark>:

```python
from .models import User

@app.task
def create_user(username, password):
    User.objects.create(username=username, password=password)
```

Для задачи также можно задать множество опций, которые можно указать в качестве аргументов декоратора:

```python
@app.task(serializer='json')
def create_user(username, password):
    User.objects.create(username=username, password=password)
```

### Как импортировать декоратор задач?

Декоратор задач доступен в вашем экземпляре приложения <mark style="color:purple;">Celery</mark>. Если вы не знаете, что это такое, прочтите «[Первые шаги с Celery](../nachalo-raboty-s-celery/pervye-shagi-s-celery.md)».

Если вы используете Django (см. <mark style="color:purple;">Первые шаги с Django</mark>) или являетесь автором библиотеки, то вам, вероятно, захочется использовать декоратор **shared\_task()**:

```python
from celery import shared_task

@shared_task
def add(x, y):
    return x + y
```

### Несколько декораторов

При использовании нескольких декораторов в сочетании с декоратором задачи вы должны убедиться, что декоратор задачи применяется последним (как ни странно, в Python это означает, что он должен быть первым в списке):

```python
@app.task
@decorator2
@decorator1
def add(x, y):
    return x + y
```

### Связанные задачи

Привязка задачи означает, что первым аргументом задачи всегда будет экземпляр задачи (**self**), точно так же, как привязанные методы Python:

```python
logger = get_task_logger(__name__)

@app.task(bind=True)
def add(self, x, y):
    logger.info(self.request.id)
```

Связанные задачи необходимы для повторных попыток (с использованием <mark style="color:purple;">app.Task.retry()</mark>), для доступа к информации о текущем запросе задачи и для любых дополнительных функций, которые вы добавляете в базовые классы пользовательских задач.

### Наследование задач

Базовый аргумент декоратора задачи определяет базовый класс задачи:

```python
import celery

class MyTask(celery.Task):

    def on_failure(self, exc, task_id, args, kwargs, einfo):
        print('{0!r} failed: {1!r}'.format(task_id, exc))

@app.task(base=MyTask)
def add(x, y):
    raise KeyError()
```

## Названия

Каждая задача должна иметь уникальное имя.

Если явное имя не указано, декоратор задачи сгенерирует его для вас, и это имя будет основано на:

1. модуле, в котором определена задача
2. имени функции задачи

Пример установки **явного** имени:

```python
>>> @app.task(name='sum-of-two-numbers')
>>> def add(x, y):
...    return x + y

>>> add.name
'sum-of-two-numbers'
```

Лучше всего использовать имя модуля в качестве пространства имен. Таким образом, имена не будут конфликтовать, если в другом модуле уже определена задача с таким именем.

```python
>>> @app.task(name='tasks.add')
>>> def add(x, y):
...    return x + y
```

Вы можете узнать имя задачи, исследовав ее атрибут `.name`:

```python
>>> add.name
'tasks.add'
```

Имя, которое мы здесь указали (`tasks.add`), — это именно то имя, которое было бы автоматически сгенерировано для нас, если бы задача была определена в модуле с именем `tasks.py`:

```python
@app.task
def add(x, y):
    return x + y
```

```python
>>> from tasks import add
>>> add.name
'tasks.add'
```

{% hint style="info" %}
Вы можете использовать команду **inspect** в воркере, чтобы просмотреть имена всех зарегистрированных задач. См. зарегистрированную команду **inspect** в разделе «<mark style="color:purple;">Утилиты командной строки управления (проверка/управление)</mark>» Руководства пользователя.
{% endhint %}

### Изменение поведения автоматического именования

> _Новое в версии 4.0._

В некоторых случаях автоматическое именование по умолчанию не подходит. Рассмотрим возможность размещения множества задач в разных модулях:

```
project/
       /__init__.py
       /celery.py
       /moduleA/
               /__init__.py
               /tasks.py
       /moduleB/
               /__init__.py
               /tasks.py
```

При использовании автоматического именования по умолчанию каждая задача будет иметь сгенерированное имя, например `moduleA.tasks.taskA`, `moduleA.tasks.taskB`, `moduleB.tasks.test` и т. д. Возможно, вы захотите избавиться от **tasks** во всех именах задач. Как указано выше, вы можете явно указывать имена для всех задач или изменить поведение автоматического именования, переопределив <mark style="color:purple;">app.gen\_task\_name()</mark>. Продолжая пример, `celery.py` может содержать:

```python
from celery import Celery

class MyCelery(Celery):

    def gen_task_name(self, name, module):
        if module.endswith('.tasks'):
            module = module[:-6]
        return super().gen_task_name(name, module)

app = MyCelery('main')
```

Таким образом, каждая задача будет иметь имя, например, `moduleA.taskA`, `moduleA.taskB` и `moduleB.test`.

{% hint style="danger" %}
Убедитесь, что ваш <mark style="color:purple;">app.gen\_task\_name()</mark> является чистой функцией: это означает, что для одного и того же ввода он всегда должен возвращать один и тот же результат.
{% endhint %}

## Объект Request задачи Task

<mark style="color:purple;">app.Task.request</mark> содержит информацию и состояние, относящиеся к выполняемой в данный момент задаче.

Запрос определяет следующие атрибуты:

* **id** - Уникальный идентификатор выполняющейся задачи
* **group** - Уникальный идентификатор группы задачи <mark style="color:purple;">group</mark>, если эта задача является ее участником.
* **chord** - Уникальный идентификатор аккорда, которому принадлежит эта задача (если задача является частью заголовка).
* **correlation\_id** - Пользовательский идентификатор, используемый для таких вещей, как дедупликация.
* **args** - Позиционные аргументы.
* **kwargs** - Аргументы ключевых слов.
* **origin** - Имя хоста, отправившего эту задачу.
* **retries** - Сколько раз была повторена текущая задача. Целое число, начинающееся с 0.
* **is\_eager** - Установите значение `True`, если задача выполняется локально на клиенте, а не воркером.
* **eta** - Исходное расчетное время ETA выполнения задачи (если есть). Это время UTC (в зависимости от настройки [enable\_utc](konfiguraciya-i-ustanovki-po-umolchaniyu.md#enable\_utc)).
* **expires** - Исходное время окончания задачи (если есть). Это время UTC (в зависимости от настройки [enable\_utc](konfiguraciya-i-ustanovki-po-umolchaniyu.md#enable\_utc)).
* **hostname** - Имя узла экземпляра воркера, выполняющего задачу.
* **delivery\_info** - Дополнительная информация о доставке сообщений. Это сопоставление, содержащее ключ обмена и маршрутизации, используемый для выполнения этой задачи. Используется, например, <mark style="color:purple;">app.Task.retry()</mark> для повторной отправки задачи в ту же очередь назначения. Доступность ключей в этом словаре зависит от используемого брокера сообщений.
* **reply-to** - Имя очереди, в которую будут отправляться ответы (например, используется с серверной частью результатов RPC).
* **called\_directly** - Этот флаг имеет значение `True`, если задача не была выполнена воркером.
* **timelimit** - Кортеж текущих (мягких, жестких) ограничений по времени, активных для этой задачи (если таковые имеются).
* **callbacks** - Список сигнатур, которые будут вызваны в случае успешного завершения этой задачи.
* **errbacks** - Список сигнатур, которые будут вызваны в случае сбоя этой задачи.
* **utc** - Если установлено значение `True`, у вызывающего абонента включено UTC ([enable\_utc](konfiguraciya-i-ustanovki-po-umolchaniyu.md#enable\_utc)).

> _Новое в версии 3.1._

* **headers** - Сопоставление заголовков сообщений, отправленных с этим сообщением задачи (может быть `None`).
* **reply\_to** - Куда отправить ответ (имя очереди).
* **correlation\_id** - Обычно совпадает с идентификатором задачи, часто используется в **amqp** для отслеживания ответа.

> _Новое в версии 4.0._

* **root\_id** - Уникальный идентификатор первой задачи в рабочем процессе, частью которого является эта задача (если есть).
* **parent\_id** - Уникальный идентификатор задачи, вызвавшей эту задачу (если есть).
* **chain** - Обратный список задач, образующих цепочку (если есть). Последний элемент в этом списке будет следующей задачей, которая придет на смену текущей задаче. При использовании первой версии протокола задач цепочка задач будет находиться в `request.callbacks`.

> _Новое в версии 5.2._

* **properties** - Сопоставление свойств сообщения, полученного с этим сообщением задачи (может быть `None` или `{}`).
* **replaced\_task\_nesting** - Сколько раз задача была заменена, если вообще была. (может быть `0`)

### Пример

Пример задачи доступа к информации в контексте:

```python
@app.task(bind=True)
def dump_context(self, x, y):
    print('Executing task id {0.id}, args: {0.args!r} kwargs: {0.kwargs!r}'.format(
            self.request))
```

Аргумент **bind** означает, что функция будет «привязанным методом», чтобы вы могли получить доступ к атрибутам и методам экземпляра типа задачи.

## Ведение журнала (логирование)

Воркер автоматически настроит вам ведение журнала, либо вы можете настроить ведение журнала вручную.

Доступен специальный регистратор с именем `"celery.task"`, который вы можете наследовать от этого регистратора, чтобы автоматически получать имя задачи и уникальный идентификатор как часть журналов.

Лучше всего создать общий регистратор для всех ваших задач в верхней части вашего модуля:

```python
from celery.utils.log import get_task_logger

logger = get_task_logger(__name__)

@app.task
def add(x, y):
    logger.info('Adding {0} + {1}'.format(x, y))
    return x + y
```

Celery использует стандартную библиотеку логгеров Python, документацию можно найти [здесь](https://docs.python.org/dev/library/logging.html#module-logging).

Вы также можете использовать [print()](https://docs.python.org/dev/library/functions.html#print), так как все, записанное в стандартный out/-err, будет перенаправлено в систему журналирования (вы можете отключить это, см. [worker\_redirect\_stdouts](konfiguraciya-i-ustanovki-po-umolchaniyu.md#worker\_redirest\_stdouts)).

{% hint style="info" %}
Воркер не будет обновлять перенаправление, если вы создадите экземпляр журнала где-то в своей задаче или модуле задач.

Если вы хотите перенаправить `sys.stdout` и `sys.stderr` в пользовательский регистратор, вам необходимо включить это вручную, например:

```python
import sys

logger = get_task_logger(__name__)

@app.task(bind=True)
def add(self, x, y):
    old_outs = sys.stdout, sys.stderr
    rlevel = self.app.conf.worker_redirect_stdouts_level
    try:
        self.app.log.redirect_stdouts_to_logger(logger, rlevel)
        print('Adding {0} + {1}'.format(x, y))
        return x + y
    finally:
        sys.stdout, sys.stderr = old_outs
```
{% endhint %}

{% hint style="info" %}
Если конкретный регистратор Celery, который вам нужен, не выдает журналы, вам следует убедиться, что регистратор распространяется правильно. В этом примере `"celery.app.trace"` включен, поэтому создаются журналы «успешного входа»:

```python
import celery
import logging

@celery.signals.after_setup_logger.connect
def on_after_setup_logger(**kwargs):
    logger = logging.getLogger('celery')
    logger.propagate = True
    logger = logging.getLogger('celery.app.trace')
    logger.propagate = True
```
{% endhint %}

{% hint style="info" %}
Если вы хотите полностью отключить конфигурацию ведения журнала Celery, используйте сигнал <mark style="color:purple;">setup\_logging</mark>:

```python
import celery

@celery.signals.setup_logging.connect
def on_setup_logging(**kwargs):
    pass
```
{% endhint %}

### Проверка аргументов

> _Новое в версии 4.0._

Celery проверит аргументы, переданные при вызове задачи, точно так же, как это делает Python при вызове обычной функции:

```python
>>> @app.task
>>> def add(x, y):
...    return x + y

# Вызов задачи с двумя аргументами работает:
>>> add.delay(8, 8)
<AsyncResult: f59d71ca-1549-43e0-be41-4e8821a83c0c>

# Вызов задачи только с одним аргументом не удался:
>>> add.delay(8)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "celery/app/task.py", line 376, in delay
    return self.apply_async(args, kwargs)
  File "celery/app/task.py", line 485, in apply_async
    check_arguments(*(args or ()), **(kwargs or {}))
TypeError: add() takes exactly 2 arguments (1 given)
```

Вы можете отключить проверку аргументов для любой задачи, установив для ее атрибута <mark style="color:purple;">typing</mark> значение `False`:

```python
>>> @app.task(typing=False)
... def add(x, y):
...    return x + y

# Работает локально, но воркер, получающий задание, выдаст ошибку.
>>> add.delay(8)
<AsyncResult: f59d71ca-1549-43e0-be41-4e8821a83c0c>
```

### Скрытие конфиденциальной информации в аргументах

> _Новое в версии 4.0._

При использовании [task\_protocol](konfiguraciya-i-ustanovki-po-umolchaniyu.md#task\_protocol) 2 или выше (по умолчанию, начиная с версии `4.0`) вы можете переопределить способ представления позиционных аргументов и аргументов ключевых слов в журналах и событиях мониторинга, используя аргументы вызова **argsrepr** и **kwargsrepr**:

```python
>>> add.apply_async((2, 3), argsrepr='(<secret-x>, <secret-y>)')

>>> charge.s(account, card='1234 5678 1234 5678').set(
...    kwargsrepr=repr({'card': '**** **** **** 5678'})
... ).delay()
```

{% hint style="danger" %}
Конфиденциальная информация по-прежнему будет доступна любому, кто сможет прочитать ваше сообщение о задании от брокера или иным образом перехватить его.

По этой причине вам, вероятно, следует зашифровать свое сообщение, если оно содержит конфиденциальную информацию, или в этом примере с номером кредитной карты фактический номер может быть сохранен в зашифрованном виде в безопасном хранилище, которое вы извлекаете и расшифровываете в самой задаче.
{% endhint %}

## Повторная попытка

<mark style="color:purple;">app.Task.retry()</mark> можно использовать для повторного выполнения задачи, например, в случае устранимых ошибок.

Когда вы вызываете функцию **retry**, она отправляет новое сообщение, используя тот же идентификатор задачи, и позаботится о том, чтобы сообщение было доставлено в ту же очередь, что и исходная задача.

Когда задача повторяется, это также записывается как состояние задачи, поэтому вы можете отслеживать ход выполнения задачи с помощью экземпляра результата (см. [Состояния](zadachi-tasks.md#sostoyaniya-states)).

Вот пример использования повтора:

```python
@app.task(bind=True)
def send_twitter_status(self, oauth, tweet):
    try:
        twitter = Twitter(oauth)
        twitter.update_status(tweet)
    except (Twitter.FailWhaleError, Twitter.LoginError) as exc:
        raise self.retry(exc=exc)
```

{% hint style="info" %}
Вызов <mark style="color:purple;">app.Task.retry()</mark> вызовет исключение, поэтому любой код после повторной попытки не будет достигнут. Это исключение <mark style="color:purple;">Retry</mark>, оно обрабатывается не как ошибка, а скорее как полупредикат, указывающий рабочему процессу, что задачу необходимо повторить, чтобы он мог сохранить правильное состояние, когда серверная часть результатов включена.

Это нормальная операция, которая происходит всегда, если для аргумента **throw** для повторной попытки не установлено значение `False`.
{% endhint %}

Аргумент **bind** декоратора задачи предоставит доступ задачи  к самой себе (экземпляр типа задачи).

Аргумент **exc** используется для передачи информации об исключениях, которая используется в журналах и при сохранении результатов задачи. И исключение, и обратная трассировка будут доступны в состоянии задачи (если включен механизм обработки результатов).

Если задача имеет значение **max\_retries**, текущее исключение будет повторно вызвано, если максимальное количество повторов будет превышено, но этого не произойдет, если:

* _Аргумент **exc** не был приведен_. В этом случае будет выдано исключение **MaxRetriesExceededError**.
* _Если исходного исключения для повторного вызова нет_, вместо него будет использоваться аргумент **exc**, поэтому:

```python
self.retry(exc=Twitter.LoginError())
```

поднимет указанный аргумент **exc**.

### Использование пользовательской задержки повтора

Когда задача должна быть повторена, она может подождать определенное количество времени, прежде чем сделать это, а задержка по умолчанию определяется атрибутом <mark style="color:purple;">default\_retry\_delay</mark>. По умолчанию установлено значение **3 минуты**. Обратите внимание, что единицей измерения задержки являются _**секунды**_ (**int** или **float**).

Вы также можете предоставить аргумент обратного отсчета **countdown** для функции <mark style="color:purple;">retry()</mark>, чтобы переопределить это значение по умолчанию.

```python
# повторите попытку через 30 минут.
@app.task(bind=True, default_retry_delay=30 * 60)
def add(self, x, y):
    try:
        something_raising()
    except Exception as exc:
        # переопределяет задержку по умолчанию для повторной попытки через 1 минуту
        raise self.retry(exc=exc, countdown=60)
```

### Автоматическая повторная попытка для известных исключений

> _Новое в версии 4.0._

Иногда вам просто нужно повторить задачу всякий раз, когда возникает определенное исключение.

К счастью, вы можете указать Celery автоматически повторить задачу, используя аргумент **autoretry\_for** в декораторе <mark style="color:purple;">app.task()</mark>:

```python
from twitter.exceptions import FailWhaleError

@app.task(autoretry_for=(FailWhaleError,))
def refresh_timeline(user):
    return twitter.refresh_timeline(user)
```

Если вы хотите указать собственные аргументы для внутреннего вызова <mark style="color:purple;">retry()</mark>, передайте аргумент **retry\_kwargs** декоратору <mark style="color:purple;">app.task()</mark>:

```python
@app.task(autoretry_for=(FailWhaleError,),
          retry_kwargs={'max_retries': 5})
def refresh_timeline(user):
    return twitter.refresh_timeline(user)
```

Это предоставляется в качестве альтернативы ручной обработке исключений, и приведенный выше пример будет делать то же самое, что и перенос тела задачи в оператор [try](https://docs.python.org/dev/reference/compound\_stmts.html#try) … [except](https://docs.python.org/dev/reference/compound\_stmts.html#except):

```python
@app.task
def refresh_timeline(user):
    try:
        twitter.refresh_timeline(user)
    except FailWhaleError as exc:
        raise refresh_timeline.retry(exc=exc, max_retries=5)
```

Если вы хотите автоматически повторить попытку при любой ошибке, просто используйте:

```python
@app.task(autoretry_for=(Exception,))
def x():
    ...
```

> _Новое в версии 4.2._

Если ваши задачи зависят от другого сервиса, например выполнение запроса к API, то рекомендуется использовать [экспоненциальную отсрочку выполнения](https://en.wikipedia.org/wiki/Exponential\_backoff), чтобы не перегружать сервис вашими запросами. К счастью, поддержка автоматической повторной попытки Celery упрощает эту задачу. Просто укажите аргумент [retry\_backoff](zadachi-tasks.md#task.retry\_backoff), например:

```python
from requests.exceptions import RequestException

@app.task(autoretry_for=(RequestException,), retry_backoff=True)
def x():
    ...
```

По умолчанию эта экспоненциальная задержка также приводит к случайному джиттеру, чтобы избежать одновременного выполнения всех задач. Он также ограничит **максимальную задержку отсрочки** до 10 минут. Все эти параметры можно настроить с помощью опций, описанных ниже.

> _Новое в версии 4.4._

Вы также можете установить параметры **autoretry\_for**, **max\_retries**, **retry\_backoff**, **retry\_backoff\_max** и **retry\_jitter** в задачах на основе классов:

```python
class BaseTaskWithRetry(Task):
    autoretry_for = (TypeError,)
    max_retries = 5
    retry_backoff = True
    retry_backoff_max = 700
    retry_jitter = False
```

#### Task.autoretry\_for

_Список/кортеж классов исключений_. Если какое-либо из этих исключений возникнет во время выполнения задачи, задача будет автоматически повторена. По умолчанию никакие исключения автоматически повторяться не будут.

#### Task.max\_retries

_Число_. Максимальное количество повторных попыток перед отказом. Значение `None` означает, что задача будет повторяться постоянно. По умолчанию для этой опции установлено значение `3`.

#### Task.retry\_backoff

_Логическое значение или число_. Если для этого параметра установлено значение `True`, автоповторные попытки будут отложены в соответствии с правилами [экспоненциальной отсрочки](https://en.wikipedia.org/wiki/Exponential\_backoff). Первая повторная попытка будет иметь задержку в 1 секунду, вторая повторная попытка будет иметь задержку в 2 секунды, третья — в 4 секунды, четвертая — в 8 секунд и так далее. (Однако это значение задержки изменяется с помощью [retry\_jitter](zadachi-tasks.md#task.retry\_jitter), если оно включено.) Если для этого параметра установлено число, оно используется как коэффициент задержки. Например, если для этого параметра установлено значение 3, первая повторная попытка задержится на 3 секунды, вторая — на 6 секунд, третья — на 12 секунд, четвертая — на 24 секунды и так далее. По умолчанию для этого параметра установлено значение `False`, и автоматические повторные попытки не будут задерживаться.

#### Task.retry\_backoff\_max

_Число_. Если **retry\_backoff** включен, этот параметр устанавливает максимальную задержку в секундах между автоматическими попытками выполнения задачи. По умолчанию для этого параметра установлено значение `600`, что составляет **10 минут**.

#### Task.retry\_jitter

_Логическое значение_. [Джиттер](https://en.wikipedia.org/wiki/Jitter) используется для придания случайности экспоненциальным задержкам отсрочки, чтобы предотвратить одновременное выполнение всех задач в очереди. Если для этого параметра установлено значение `True`, значение задержки, рассчитанное с помощью [retry\_backoff](zadachi-tasks.md#task.retry\_backoff), рассматривается как максимальное, а фактическое значение задержки будет случайным числом между нулем и этим максимумом. По умолчанию для этого параметра установлено значение `True`.

> _Новое в версии 5.3.0_

#### Task.dont\_autoretry\_for

_Список/кортеж классов исключений_. Эти исключения не будут автоматически повторяться. Это позволяет исключить некоторые исключения, соответствующие [autoretry\_for](zadachi-tasks.md#task.autoretry\_for), но повторная попытка которых не требуется.

## Список параметров

Декоратор задачи может принимать ряд параметров, которые изменяют поведение задачи, например, вы можете установить ограничение скорости для задачи, используя опцию **rate\_limit**.

Любой аргумент ключевого слова, переданный декоратору задачи, фактически будет установлен как атрибут результирующего класса задачи, и ниже приведен список встроенных атрибутов.

### Общие

#### Task.name

Имя, под которым зарегистрирована задача.

Вы можете задать это имя вручную или имя будет сгенерировано автоматически с использованием имени модуля и класса.

См. также [Названия](zadachi-tasks.md#nazvaniya).

#### Task.request

Если задача выполняется, она будет содержать информацию о текущем запросе. Используется локальное хранилище потока.

См. [Запрос задачи](zadachi-tasks.md#obekt-request-zadachi-task).

#### Task.max\_retries

Применяется только в том случае, если задача вызывает `self.retry` или если задача дополнена аргументом [autoretry\_for](zadachi-tasks.md#task.autoretry\_for).

Максимальное количество повторных попыток до отказа. Если количество повторов превысит это значение, будет выдано исключение <mark style="color:purple;">MaxRetriesExceededError</mark>.

{% hint style="info" %}
Вам придется вызывать функцию <mark style="color:purple;">retry()</mark> вручную, так как она не будет автоматически повторять попытку при исключении.
{% endhint %}

Значение по умолчанию — **3**. Значение `None` отключит ограничение повторов, и задача будет повторяться бесконечно, пока не достигнет успеха.

#### Task.throws

Необязательный кортеж ожидаемых классов ошибок, которые не следует рассматривать как фактическую ошибку.

Об ошибках в этом списке будет сообщено серверной части результатов как сбой, но исполнитель не зарегистрирует событие как ошибку, и обратная трассировка не будет включена.

Пример:

```python
@task(throws=(KeyError, HttpNotFound)):
def get_foo():
    something()
```

Типы ошибок:

* _Ожидаемые ошибки (в `Task.throws`)_. Записывается с уровнем логирования **INFO**, обратная трассировка исключена.
* _Неожиданные ошибки_. Зарегистрировано с уровнем логирования **ERROR**, включая обратную трассировку.

#### Task.default\_retry\_delay

Время по умолчанию в секундах, прежде чем должна быть выполнена повторная попытка задачи. Может быть либо [int](https://docs.python.org/dev/library/functions.html#int), либо [float](https://docs.python.org/dev/library/functions.html#float). По умолчанию установлена **трехминутная** задержка.

#### Task.rate\_limit

Устанавливает ограничение скорости для этого типа задач (ограничивает количество задач, которые можно запустить в заданный период времени). Задачи по-прежнему будут выполняться, если действует ограничение скорости, но может пройти некоторое время, прежде чем их запуск будет разрешен.

Если установлено значение `None`, ограничение скорости не действует. Если это целое число **int** или число с плавающей запятой **float**, оно интерпретируется как «число задач в секунду».

Ограничения скорости можно указать в секундах, минутах или часах, добавив к значению `"/s"`, `"/m"` или `"/h"`. Задачи будут равномерно распределены по заданному временному интервалу.

Пример: `"100/m"` (сто задач в минуту). Это обеспечит минимальную задержку в 600 мс между запуском двух задач в одном рабочем экземпляре.

По умолчанию используется параметр [task\_default\_rate\_limit](konfiguraciya-i-ustanovki-po-umolchaniyu.md#task\_default\_rate\_limit): если он не указан, это означает, что ограничение скорости для задач отключено по умолчанию.

Обратите внимание, что это ограничение скорости для **каждого экземпляра воркера**, а не глобальное ограничение скорости. Чтобы применить глобальное ограничение скорости (например, для API с максимальным количеством запросов в секунду), вы должны ограничить данную очередь.

#### Task.time\_limit

Жесткий лимит времени в секундах для этой задачи. Если этот параметр не установлен, используются значения воркера по умолчанию.

#### Task.soft\_time\_limit

Мягкое ограничение времени для этой задачи. Если этот параметр не установлен, используются значения воркера по умолчанию.

#### Task.ignore\_result

Не сохранять состояние задачи. Обратите внимание: это означает, что вы не можете использовать <mark style="color:purple;">AsyncResult</mark> для проверки готовности задачи или получения ее возвращаемого значения.

{% hint style="info" %}
Некоторые функции не будут работать, если результаты задач отключены. Для получения более подробной информации ознакомьтесь с **документацией Canvas**.
{% endhint %}

#### Task.store\_errors\_even\_if\_ignored

Если задано значение `True`, ошибки будут сохраняться, даже если задача настроена на игнорирование результатов.

#### Task.serializer

Строка, определяющая используемый метод сериализации по умолчанию. По умолчанию используется параметр [task\_serializer](konfiguraciya-i-ustanovki-po-umolchaniyu.md#task\_serializer). Это может быть pickle, json, yaml или любые пользовательские методы сериализации, зарегистрированные в **kombu.serialization.registry**.

Дополнительную информацию см. в разделе [Сериализаторы](vyzov-zadach.md#serializatory).

#### Task.compression

Строка, определяющая используемую схему сжатия по умолчанию.

По умолчанию используется параметр [task\_compression](konfiguraciya-i-ustanovki-po-umolchaniyu.md#task\_compression). Это может быть gzip, bzip2 или любые пользовательские схемы сжатия, зарегистрированные в реестре **kombu.compression**.

Дополнительную информацию см. в разделе [Сжатие](vyzov-zadach.md#szhatie-compression).

#### Task.backend

Серверная часть хранилища результатов, используемая для этой задачи. Экземпляр одного из серверных классов в `celery.backends`. По умолчанию — `app.backend`, определяемый настройкой [result\_backend](konfiguraciya-i-ustanovki-po-umolchaniyu.md#result\_backend).

#### Tasks.acks\_late

Если установлено значение `True`, сообщения для этой задачи будут подтверждены **после** выполнения задачи, а _не непосредственно перед ее выполнением_ (поведение по умолчанию).

{% hint style="info" %}
Это означает, что задача может выполняться несколько раз, если рабочий процесс выйдет из строя в середине выполнения. Убедитесь, что ваши задачи <mark style="color:purple;">идемпотентны</mark>.
{% endhint %}

Глобальное значение по умолчанию можно переопределить с помощью параметра [task\_acks\_late](konfiguraciya-i-ustanovki-po-umolchaniyu.md#task\_acks\_late).

#### Task.track\_started

Если принимает значение `True`, задача сообщит о своем статусе как `"started"`, когда задача выполняется воркером. Значение по умолчанию — `False`, поскольку обычное поведение заключается в том, чтобы не сообщать о таком уровне детализации. Задачи либо ожидают выполнения, либо завершены, либо ожидают повторной попытки. Статус `"started"` может быть полезен, когда есть долго выполняющиеся задачи и необходимо сообщить, какая задача выполняется в данный момент.

Имя хоста и идентификатор процесса воркера, выполняющего задачу, будут доступны в метаданных состояния (например, `result.info['pid']`).

Глобальное значение по умолчанию можно переопределить с помощью параметра [task\_track\_started](konfiguraciya-i-ustanovki-po-umolchaniyu.md#task\_track\_started).

{% hint style="success" %}
**Смотрите также:**

Ссылка на API для <mark style="color:purple;">Task</mark>.
{% endhint %}

## Состояния (states)

Celery может отслеживать текущее состояние задач. Состояние также содержит результат успешного выполнения задачи или информацию об исключении и отслеживании неудачной задачи.

На выбор предлагается несколько серверов обработки результатов (_result backend_), и все они имеют разные сильные и слабые стороны (см. [Серверы результатов](zadachi-tasks.md#servernye-chasti-rezultatov)).

В течение своего существования задача будет переходить через несколько возможных состояний, и к каждому состоянию могут быть прикреплены произвольные метаданные. Когда задача переходит в новое состояние, о предыдущем состоянии забывают, но некоторые переходы можно вывести (например, задача, которая сейчас находится в состоянии **FAILED**, подразумевает, что в какой-то момент находилась в состоянии [STARTED](zadachi-tasks.md#started)).

Существуют также наборы состояний, например набор **FAILURE\_STATES** и набор <mark style="color:purple;">READY\_STATES</mark>.

Клиент использует членство в этих наборах, чтобы решить, следует ли повторно вызвать исключение (<mark style="color:purple;">PROPAGATE\_STATES</mark>) или можно ли кэшировать состояние (это возможно, если задача готова).

Вы также можете определить [пользовательские состояния](zadachi-tasks.md#polzovatelskie-sostoyaniya).

### Серверные части результатов

Если вы хотите отслеживать задачи или вам нужны возвращаемые значения, тогда Celery должен хранить или отправлять куда-то состояния, чтобы их можно было получить позже. На выбор можно выбрать несколько встроенных серверов обработки результатов: **SQLAlchemy/Django ORM**, **Memcached**, **RabbitMQ/QPid (rpc)** и **Redis** – или вы можете определить свой собственный.

Ни один бэкэнд не работает хорошо для каждого варианта использования. Вам следует прочитать о сильных и слабых сторонах каждого бэкэнда и выбрать наиболее подходящий для ваших нужд.

{% hint style="danger" %}
Серверные части используют ресурсы для хранения и передачи результатов. Чтобы гарантировать освобождение ресурсов, вы должны в конечном итоге вызвать <mark style="color:purple;">get()</mark> или <mark style="color:purple;">ignore()</mark> для КАЖДОГО экземпляра <mark style="color:purple;">AsyncResult</mark>, возвращаемого после вызова задачи.
{% endhint %}

{% hint style="success" %}
**Смотрите также:**

[Настройки серверной части результатов задачи](konfiguraciya-i-ustanovki-po-umolchaniyu.md#nastroiki-servernoi-chasti-rezultatov-zadachi).
{% endhint %}

### Серверная часть результатов RPC (RabbitMQ/QPid)

Серверная часть результатов RPC (`rpc://`) уникальна, поскольку на самом деле она **не сохраняет состояния**, а скорее отправляет их в виде сообщений. Это важное отличие, поскольку означает, что результат может быть **получен только один раз и только клиентом, инициировавшим задачу**. Два разных процесса не могут дождаться одного и того же результата.

Даже с учетом этого ограничения это отличный выбор, если вам нужно получать изменения состояния в режиме реального времени. Использование обмена сообщениями означает, что клиенту не нужно опрашивать новые состояния.

По умолчанию сообщения являются временными (непостоянными), поэтому результаты исчезнут, если брокер перезапустится. Вы можете настроить серверную часть результатов для отправки постоянных сообщений, используя параметр result\_persistent.

### Серверная часть результатов базы данных

Хранение состояния в базе данных может быть удобным для многих, особенно для веб-приложений с уже существующей базой данных, но оно также имеет ограничения.

* Опрос базы данных на наличие новых состояний требует больших затрат, поэтому вам следует увеличить интервалы опроса операций, таких как `result.get()`.
* Некоторые базы данных используют уровень изоляции транзакций по умолчанию, который не подходит для опроса таблиц на наличие изменений. В **MySQL** уровень изоляции транзакции по умолчанию — **REPEATABLE-READ**: это означает, что транзакция не увидит изменений, внесенных другими транзакциями, пока текущая транзакция не будет зафиксирована. Рекомендуется изменить его на уровень изоляции **READ-COMMITTED**.

### Встроенные состояния

#### PENDING

Задача ожидает выполнения или неизвестна. Любой неизвестный идентификатор задачи подразумевает, что он находится в состоянии ожидания.

#### STARTED

Задача запущена. По умолчанию не сообщается. Чтобы включить, см. <mark style="color:purple;">app.Task.track\_started</mark>.

* **meta-data**: **pid** и **hostname** процесса воркера, выполняющего задачу.

#### SUCCESS

Задача успешно выполнена.

* **meta-data**: **result** содержит возвращаемое значение задачи.
* **propagates**: Да
* **ready**: Да

#### FAILURE

Выполнение задачи закончилось неудачей.

* **meta-data**: **result** содержит возникшее исключение, а трассировка **traceback** содержит обратную трассировку стека в момент возникновения исключения.
* **propagates**: Да

#### RETRY

Задача повторяется.

* meta-data: **result** содержит исключение, вызвавшее повторную попытку, а трассировка **traceback** содержит обратную трассировку стека в момент возникновения исключения.
* propagates: Нет

#### REVOKED

Задача отозвана.

* **propagates**: Да

### Пользовательские состояния

Вы можете легко определять свои собственные состояния, все, что вам нужно, это уникальное имя. Имя состояния обычно представляет собой строку в верхнем регистре. В качестве примера вы можете взглянуть на прерываемые задачи **abortable task**, которые определяют пользовательское состояние **ABORTED**.

Используйте <mark style="color:purple;">update\_state()</mark> для обновления состояния задачи:

```python
@app.task(bind=True)
def upload_files(self, filenames):
    for i, file in enumerate(filenames):
        if not self.request.called_directly:
            self.update_state(state='PROGRESS',
                meta={'current': i, 'total': len(filenames)})
```

Здесь я создал состояние `"PROGRESS"`, сообщая любому приложению, знающему об этом состоянии, что задача в данный момент выполняется, а также о том, где она находится в процессе, используя текущие и общие счетчики как часть метаданных состояния. Затем это можно использовать, например, для создания индикаторов выполнения.

### Создание выбираемых (pickleable) исключений

Редко известный факт Python заключается в том, что исключения должны соответствовать некоторым простым правилам, чтобы поддерживать сериализацию модулем **pickle**.

Задачи, вызывающие исключения, которые невозможно выбрать, не будут работать должным образом, если в качестве сериализатора используется **pickle**.

Чтобы гарантировать возможность выбора исключений, исключение ДОЛЖНО предоставить исходные аргументы, с которыми оно было создано, в своем атрибуте `.args`. Самый простой способ обеспечить это — вызвать исключение `Exception.__init__`.

Давайте посмотрим на несколько примеров, которые работают, а некоторые нет:

```python
# OK:
class HttpError(Exception):
    pass

# BAD:
class HttpError(Exception):

    def __init__(self, status_code):
        self.status_code = status_code

# OK:
class HttpError(Exception):

    def __init__(self, status_code):
        self.status_code = status_code
        Exception.__init__(self, status_code)  # <-- REQUIRED
```

Итак, правило таково: для любого исключения, поддерживающего пользовательские аргументы `*args`, необходимо использовать `Exception.__init__(self, *args)`.

Специальной поддержки _**аргументов ключевых слов**_ не существует, поэтому, если вы хотите сохранить аргументы ключевых слов при распаковке исключения, вам придется передавать их как обычные аргументы:

```python
class HttpError(Exception):

    def __init__(self, status_code, headers=None, body=None):
        self.status_code = status_code
        self.headers = headers
        self.body = body

        super(HttpError, self).__init__(status_code, headers, body)
```

## Полупредикаты

Воркер оборачивает задачу в функцию трассировки, которая записывает окончательное состояние задачи. Существует ряд исключений, которые можно использовать, чтобы сигнализировать этой функции об изменении способа обработки возврата задачи.

### Ignore

Задача может вызвать <mark style="color:purple;">Ignore</mark>, чтобы заставить воркер игнорировать задачу. Это означает, что состояние задачи не будет записано, но сообщение все равно будет подтверждено (удалено из очереди).

Это можно использовать, если вы хотите реализовать пользовательскую функциональность, подобную отзыву, или вручную сохранить результат задачи.

Пример хранения отозванных задач в наборе **Redis**:

```python
from celery.exceptions import Ignore

@app.task(bind=True)
def some_task(self):
    if redis.ismember('tasks.revoked', self.request.id):
        raise Ignore()
```

Пример сохранения результатов вручную:

```python
from celery import states
from celery.exceptions import Ignore

@app.task(bind=True)
def get_tweets(self, user):
    timeline = twitter.get_timeline(user)
    if not self.request.called_directly:
        self.update_state(state=states.SUCCESS, meta=timeline)
    raise Ignore()
```

### Reject

Задача может вызвать <mark style="color:purple;">Reject</mark>, чтобы отклонить сообщение задачи, используя метод **basic\_reject** AMQP. Это не будет иметь никакого эффекта, если [Task.acks\_late](zadachi-tasks.md#tasks.acks\_late) не включен.

Отклонение сообщения имеет тот же эффект, что и его подтверждение, но некоторые брокеры могут реализовывать дополнительные функции, которые можно использовать. Например, RabbitMQ поддерживает концепцию [обмена недоставленными письмами](http://www.rabbitmq.com/dlx.html), при которой очередь может быть настроена на использование обмена недоставленными письмами, в который повторно доставляются отклоненные сообщения.

**Reject** также можно использовать для повторной постановки сообщений в очередь, но будьте очень осторожны при его использовании, так как это может легко привести к бесконечному циклу сообщений.

Пример использования отклонения, когда задача вызывает нехватку памяти:

```python
import errno
from celery.exceptions import Reject

@app.task(bind=True, acks_late=True)
def render_scene(self, path):
    file = get_file(path)
    try:
        renderer.render_scene(file)

    # если файл слишком велик, чтобы поместиться в памяти, мы отклоняем его,
    # и он повторно доставляется в пункт обмена недоставленными письмами,
    # и мы можем вручную проверить ситуацию.
    except MemoryError as exc:
        raise Reject(exc, requeue=False)
    except OSError as exc:
        if exc.errno == errno.ENOMEM:
            raise Reject(exc, requeue=False)

    # В случае любой другой ошибки мы повторяем попытку через 10 секунд.
    except Exception as exc:
        raise self.retry(exc, countdown=10)
```

Пример повторной постановки сообщения в очередь:

```python
from celery.exceptions import Reject

@app.task(bind=True, acks_late=True)
def requeues(self):
    if not self.request.delivery_info['redelivered']:
        raise Reject('no reason', requeue=True)
    print('received two times')
```

Обратитесь к документации вашего брокера для получения более подробной информации о методе **basic\_reject**.

### Retry

Исключение <mark style="color:purple;">Retry</mark> вызывается методом `Task.retry`, чтобы сообщить воркеру, что задача повторяется.
