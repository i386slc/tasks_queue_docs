# Задачи (tasks)

Задачи — это строительные блоки приложений **Celery**.

Задача — это класс, который можно создать _**из любого вызываемого объекта**_. Он выполняет двойную роль: определяет, что происходит, когда задача вызывается (отправляет сообщение), и что происходит, когда воркер получает это сообщение.

Каждый класс задач имеет уникальное имя, и на это имя ссылаются в сообщениях, чтобы воркер мог найти нужную функцию для выполнения.

Сообщение задачи не удаляется из очереди до тех пор, пока это сообщение не будет <mark style="color:purple;">подтверждено исполнителем</mark>. Воркер может заранее зарезервировать множество сообщений, и даже если воркер будет убит – из-за сбоя питания или по какой-либо другой причине – сообщение будет повторно доставлено другому воркеру.

В идеале функции задач должны быть <mark style="color:purple;">идемпотентными</mark>: это означает, что функция не будет вызывать непредвиденных эффектов, даже если она будет вызываться несколько раз с одними и теми же аргументами. Поскольку процесс воркера не может определить, являются ли ваши задачи идемпотентными, поведением по умолчанию является подтверждение сообщения заранее, непосредственно перед его выполнением, чтобы уже начатый вызов задачи никогда не выполнялся снова.

Если ваша задача идемпотентна, вы можете установить опцию [acks\_late](zadachi-tasks.md#tasks.acks\_late), чтобы вместо этого воркер подтверждал сообщение после возврата задачи. См. также раздел часто задаваемых вопросов. <mark style="color:purple;">Должен ли я использовать retry или acks\_late?</mark>.

Обратите внимание, что процесс воркера подтвердит сообщение, если дочерний процесс, выполняющий задачу, завершается (либо задачей, вызывающей [sys.exit()](https://docs.python.org/dev/library/sys.html#sys.exit), либо сигналом), даже если [acks\_late](zadachi-tasks.md#tasks.acks\_late) включен. Такое поведение является преднамеренным, поскольку…

1. Мы не хотим перезапускать задачи, которые заставляют ядро отправлять процессу **SIGSEGV** (ошибка сегментации) или подобные сигналы.
2. Мы предполагаем, что системный администратор, намеренно уничтоживший задачу, не хочет, чтобы она автоматически перезапускалась.
3. Задача, которая выделяет слишком много памяти, может вызвать срабатывание убийцы OOM ядра, то же самое может произойти снова.
4. Задача, которая всегда терпит неудачу при повторной доставке, может вызвать высокочастотный цикл сообщений, приводящий к сбою системы.

Если вы действительно хотите, чтобы задача была повторно доставлена в этих сценариях, вам следует рассмотреть возможность включения параметра <mark style="color:purple;">task\_reject\_on\_worker\_lost</mark>.

{% hint style="danger" %}
Задача, которая блокируется на неопределенный срок, может в конечном итоге помешать экземпляру воркера выполнять любую другую работу.

Если ваша задача выполняет ввод-вывод, обязательно добавьте таймауты к этим операциям, например, добавив таймаут к веб-запросу с помощью библиотеки [requests](https://pypi.python.org/pypi/requests/):&#x20;

```python
connect_timeout, read_timeout = 5.0, 30.0
response = requests.get(URL, timeout=(connect_timeout, read_timeout))
```

<mark style="color:purple;">Ограничения по времени</mark> удобны для обеспечения своевременного возврата всех задач, но событие ограничения по времени фактически принудительно останавливает процесс, поэтому используйте их только для обнаружения случаев, когда вы еще не использовали тайм-ауты вручную.

В предыдущих версиях планировщик пула **prefork** по умолчанию не был дружелюбен к длительным задачам, поэтому, если у вас были задачи, которые выполнялись в течение минут/часов, рекомендуется включить аргумент командной строки <mark style="color:purple;">-Ofair</mark> для **celery worker**. Однако, начиная с версии 4.0, `-Ofair` теперь является стратегией планирования по умолчанию. Дополнительные сведения см. в разделе «<mark style="color:purple;">Ограничения предварительной выборки</mark>», а также для обеспечения наилучшей производительности маршрутизации длительных и кратковременных задач выделенным исполнителям (<mark style="color:purple;">автоматическая маршрутизация</mark>).

Если ваш воркер зависает, прежде чем сообщать о проблеме, выясните, какие задачи выполняются, поскольку, скорее всего, зависание вызвано одной или несколькими задачами, зависающими в сетевой операции.
{% endhint %}

В этой главе вы узнаете все об определении задач, а вот ее содержание:

* [Основы](zadachi-tasks.md#osnovy)
* [Названия](zadachi-tasks.md#nazvaniya)
* [Объект Request задачи Task](zadachi-tasks.md#obekt-request-zadachi-task)
* [Ведение журнала](zadachi-tasks.md#vedenie-zhurnala-logirovanie)
* Повторная попытка
* [Список параметров](zadachi-tasks.md#spisok-parametrov)
* Состояния
* Полупредикаты
* Пользовательские классы задач
* Как это работает
* Советы и лучшие практики
* Производительность и стратегии
* Пример

## Основы

Вы можете легко создать задачу из любого вызываемого объекта, используя декоратор <mark style="color:purple;">app.task()</mark>:

```python
from .models import User

@app.task
def create_user(username, password):
    User.objects.create(username=username, password=password)
```

Для задачи также можно задать множество опций, которые можно указать в качестве аргументов декоратора:

```python
@app.task(serializer='json')
def create_user(username, password):
    User.objects.create(username=username, password=password)
```

### Как импортировать декоратор задач?

Декоратор задач доступен в вашем экземпляре приложения <mark style="color:purple;">Celery</mark>. Если вы не знаете, что это такое, прочтите «[Первые шаги с Celery](../nachalo-raboty-s-celery/pervye-shagi-s-celery.md)».

Если вы используете Django (см. <mark style="color:purple;">Первые шаги с Django</mark>) или являетесь автором библиотеки, то вам, вероятно, захочется использовать декоратор **shared\_task()**:

```python
from celery import shared_task

@shared_task
def add(x, y):
    return x + y
```

### Несколько декораторов

При использовании нескольких декораторов в сочетании с декоратором задачи вы должны убедиться, что декоратор задачи применяется последним (как ни странно, в Python это означает, что он должен быть первым в списке):

```python
@app.task
@decorator2
@decorator1
def add(x, y):
    return x + y
```

### Связанные задачи

Привязка задачи означает, что первым аргументом задачи всегда будет экземпляр задачи (**self**), точно так же, как привязанные методы Python:

```python
logger = get_task_logger(__name__)

@app.task(bind=True)
def add(self, x, y):
    logger.info(self.request.id)
```

Связанные задачи необходимы для повторных попыток (с использованием <mark style="color:purple;">app.Task.retry()</mark>), для доступа к информации о текущем запросе задачи и для любых дополнительных функций, которые вы добавляете в базовые классы пользовательских задач.

### Наследование задач

Базовый аргумент декоратора задачи определяет базовый класс задачи:

```python
import celery

class MyTask(celery.Task):

    def on_failure(self, exc, task_id, args, kwargs, einfo):
        print('{0!r} failed: {1!r}'.format(task_id, exc))

@app.task(base=MyTask)
def add(x, y):
    raise KeyError()
```

## Названия

Каждая задача должна иметь уникальное имя.

Если явное имя не указано, декоратор задачи сгенерирует его для вас, и это имя будет основано на:

1. модуле, в котором определена задача
2. имени функции задачи

Пример установки **явного** имени:

```python
>>> @app.task(name='sum-of-two-numbers')
>>> def add(x, y):
...    return x + y

>>> add.name
'sum-of-two-numbers'
```

Лучше всего использовать имя модуля в качестве пространства имен. Таким образом, имена не будут конфликтовать, если в другом модуле уже определена задача с таким именем.

```python
>>> @app.task(name='tasks.add')
>>> def add(x, y):
...    return x + y
```

Вы можете узнать имя задачи, исследовав ее атрибут `.name`:

```python
>>> add.name
'tasks.add'
```

Имя, которое мы здесь указали (`tasks.add`), — это именно то имя, которое было бы автоматически сгенерировано для нас, если бы задача была определена в модуле с именем `tasks.py`:

```python
@app.task
def add(x, y):
    return x + y
```

```python
>>> from tasks import add
>>> add.name
'tasks.add'
```

{% hint style="info" %}
Вы можете использовать команду **inspect** в воркере, чтобы просмотреть имена всех зарегистрированных задач. См. зарегистрированную команду **inspect** в разделе «<mark style="color:purple;">Утилиты командной строки управления (проверка/управление)</mark>» Руководства пользователя.
{% endhint %}

### Изменение поведения автоматического именования

> _Новое в версии 4.0._

В некоторых случаях автоматическое именование по умолчанию не подходит. Рассмотрим возможность размещения множества задач в разных модулях:

```
project/
       /__init__.py
       /celery.py
       /moduleA/
               /__init__.py
               /tasks.py
       /moduleB/
               /__init__.py
               /tasks.py
```

При использовании автоматического именования по умолчанию каждая задача будет иметь сгенерированное имя, например `moduleA.tasks.taskA`, `moduleA.tasks.taskB`, `moduleB.tasks.test` и т. д. Возможно, вы захотите избавиться от **tasks** во всех именах задач. Как указано выше, вы можете явно указывать имена для всех задач или изменить поведение автоматического именования, переопределив <mark style="color:purple;">app.gen\_task\_name()</mark>. Продолжая пример, `celery.py` может содержать:

```python
from celery import Celery

class MyCelery(Celery):

    def gen_task_name(self, name, module):
        if module.endswith('.tasks'):
            module = module[:-6]
        return super().gen_task_name(name, module)

app = MyCelery('main')
```

Таким образом, каждая задача будет иметь имя, например, `moduleA.taskA`, `moduleA.taskB` и `moduleB.test`.

{% hint style="danger" %}
Убедитесь, что ваш <mark style="color:purple;">app.gen\_task\_name()</mark> является чистой функцией: это означает, что для одного и того же ввода он всегда должен возвращать один и тот же результат.
{% endhint %}

## Объект Request задачи Task

<mark style="color:purple;">app.Task.request</mark> содержит информацию и состояние, относящиеся к выполняемой в данный момент задаче.

Запрос определяет следующие атрибуты:

* **id** - Уникальный идентификатор выполняющейся задачи
* **group** - Уникальный идентификатор группы задачи <mark style="color:purple;">group</mark>, если эта задача является ее участником.
* **chord** - Уникальный идентификатор аккорда, которому принадлежит эта задача (если задача является частью заголовка).
* **correlation\_id** - Пользовательский идентификатор, используемый для таких вещей, как дедупликация.
* **args** - Позиционные аргументы.
* **kwargs** - Аргументы ключевых слов.
* **origin** - Имя хоста, отправившего эту задачу.
* **retries** - Сколько раз была повторена текущая задача. Целое число, начинающееся с 0.
* **is\_eager** - Установите значение `True`, если задача выполняется локально на клиенте, а не воркером.
* **eta** - Исходное расчетное время ETA выполнения задачи (если есть). Это время UTC (в зависимости от настройки [enable\_utc](konfiguraciya-i-ustanovki-po-umolchaniyu.md#enable\_utc)).
* **expires** - Исходное время окончания задачи (если есть). Это время UTC (в зависимости от настройки [enable\_utc](konfiguraciya-i-ustanovki-po-umolchaniyu.md#enable\_utc)).
* **hostname** - Имя узла экземпляра воркера, выполняющего задачу.
* **delivery\_info** - Дополнительная информация о доставке сообщений. Это сопоставление, содержащее ключ обмена и маршрутизации, используемый для выполнения этой задачи. Используется, например, <mark style="color:purple;">app.Task.retry()</mark> для повторной отправки задачи в ту же очередь назначения. Доступность ключей в этом словаре зависит от используемого брокера сообщений.
* **reply-to** - Имя очереди, в которую будут отправляться ответы (например, используется с серверной частью результатов RPC).
* **called\_directly** - Этот флаг имеет значение `True`, если задача не была выполнена воркером.
* **timelimit** - Кортеж текущих (мягких, жестких) ограничений по времени, активных для этой задачи (если таковые имеются).
* **callbacks** - Список сигнатур, которые будут вызваны в случае успешного завершения этой задачи.
* **errbacks** - Список сигнатур, которые будут вызваны в случае сбоя этой задачи.
* **utc** - Если установлено значение `True`, у вызывающего абонента включено UTC ([enable\_utc](konfiguraciya-i-ustanovki-po-umolchaniyu.md#enable\_utc)).

> _Новое в версии 3.1._

* **headers** - Сопоставление заголовков сообщений, отправленных с этим сообщением задачи (может быть `None`).
* **reply\_to** - Куда отправить ответ (имя очереди).
* **correlation\_id** - Обычно совпадает с идентификатором задачи, часто используется в **amqp** для отслеживания ответа.

> _Новое в версии 4.0._

* **root\_id** - Уникальный идентификатор первой задачи в рабочем процессе, частью которого является эта задача (если есть).
* **parent\_id** - Уникальный идентификатор задачи, вызвавшей эту задачу (если есть).
* **chain** - Обратный список задач, образующих цепочку (если есть). Последний элемент в этом списке будет следующей задачей, которая придет на смену текущей задаче. При использовании первой версии протокола задач цепочка задач будет находиться в `request.callbacks`.

> _Новое в версии 5.2._

* **properties** - Сопоставление свойств сообщения, полученного с этим сообщением задачи (может быть `None` или `{}`).
* **replaced\_task\_nesting** - Сколько раз задача была заменена, если вообще была. (может быть `0`)

### Пример

Пример задачи доступа к информации в контексте:

```python
@app.task(bind=True)
def dump_context(self, x, y):
    print('Executing task id {0.id}, args: {0.args!r} kwargs: {0.kwargs!r}'.format(
            self.request))
```

Аргумент **bind** означает, что функция будет «привязанным методом», чтобы вы могли получить доступ к атрибутам и методам экземпляра типа задачи.

## Ведение журнала (логирование)

## Список параметров

### Общие

#### Tasks.acks\_late
